[
  {
    "id": "HumanEval/example",
    "prompt": "from typing import List\nimport sys\n\ndef longest_subarray_with_sum_limit(nums: List[int], target: int) -> List[int]:\n    \"\"\" Find the longest subarray of the given array `nums` such that the sum of its elements is less than or equal to the given `target`.\n    >>> longest_subarray_with_sum_limit([3, 1, 5, 2, 1, 9, 7, 4], 10)\n    [3, 1, 5]\n    >>> longest_subarray_with_sum_limit([1, 2, 3, 4, 5], 3)\n    [1, 2]\n    \"\"\"",
    "requirements": "- Problem Agnostic Requirements\n  - Ensure error-free execution, avoiding type errors, index errors, arithmetic operation errors (e.g., division by zero, overflow), and so on.\n  - Demonstrate efficiency in the algorithmic approach to problem-solving.\n  - Code should be clear, well-commented, and easy to understand and maintain.\n\n- Functional Requirements\n  - Input-output Conditions\n    - The function takes a list of integers `nums` and a target integer `target` as input.\n    - It returns a list of integers.\n\n  - Expected Behavior\n    - The function should return the longest subarray of `nums` whose sum is less than or equal to `target`.\n\n  - Edge Cases\n    - Handle an empty `nums` list, returning an empty list.\n    - Handle the case where no subarray in `nums` satisfies the condition, returning an empty list.\n    - Handle multiple subarrays with the same maximum length, returning any of them.\n\n- Non-functional Requirements\n  - Performance\n    - Time complexity: O(n) where n is the length of the `nums` list.\n    - Space complexity: O(1).\n    - Ensure efficiency even for extremely large inputs, providing results within 5 seconds.\n\n  - Specific Quality Requirements\n    - Robustness\n      - If non-list `nums` input or a non-integer `target` input is provided, print an error message to `stderr` and return None.\n      - If non-integer elements in the `nums` list or a negative `target` is provided, print an error message to `stderr` and return None.\n\n    - Reliability\n      - Avoid index errors while accessing `nums` elements.\n\n    - Maintainability\n      - Target Maintainability Index: >= 60.",
    "requirements_fr": "- Problem Agnostic Requirements\n  - Ensure error-free execution, avoiding type errors, index errors, arithmetic operation errors (e.g., division by zero, overflow), and so on.\n  - Demonstrate efficiency in the algorithmic approach to problem-solving.\n  - Code should be clear, well-commented, and easy to understand and maintain.\n\n- Functional Requirements\n  - Input-output Conditions\n    - The function takes a list of integers `nums` and a target integer `target` as input.\n    - It returns a list of integers.\n\n  - Expected Behavior\n    - The function should return the longest subarray of `nums` whose sum is less than or equal to `target`.\n\n  - Edge Cases\n    - Handle an empty `nums` list, returning an empty list.\n    - Handle the case where no subarray in `nums` satisfies the condition, returning an empty list.\n    - Handle multiple subarrays with the same maximum length, returning any of them.",
    "gen_tc": "# Test Cases Regarding Functional Requirements\n## General Cases\n### The longest subarray with sum less than or equal to 10 is [1, 5, 2, 1]\nassert longest_subarray_with_sum_limit([3, 1, 5, 2, 1, 9, 7, 4], 10) == [1, 5, 2, 1], 'Failed to find the longest subarray.'\n\n### None of the subarrays have a sum less than or equal to 3\n### The function should return an empty list\nassert longest_subarray_with_sum_limit([2, 3, 4, 5, 6], 1) == [], 'Failed to handle case where no subarray satisfies the condition.'\n\n## Edge Cases\n### The input list is empty, so the function should return an empty list\nassert longest_subarray_with_sum_limit([], 5) == [], 'Failed to handle an empty input list.'\n\n### The longest subarray with sum less than or equal to 10 is [5, 5]\nassert longest_subarray_with_sum_limit([5, 5, 5, 5], 10) == [5, 5], 'Failed to find the longest subarray when all elements have the same value.'\n\n### The entire nums array is a valid subarray with sum less than or equal to 15\nassert longest_subarray_with_sum_limit([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5], 'Failed to handle case where the entire array is a valid subarray.'\n\n# Test Cases Regarding Non-functional Requirements\n## Performance Requirements\n### The nums list contains 10^6 elements with increasing values from 1 to 10^6\n### The longest subarray with sum less than or equal to 10^5 is [1, 2, 3, ..., 10^5]\nassert longest_subarray_with_sum_limit(list(range(1, 10**6 + 1)), 10**5) == list(range(1, 446 + 1)), 'Failed to handle large input size.'\n\n### The nums list contains 10^6 elements with increasing values from 1 to 10^6\n### The longest subarray with sum less than or equal to 2 is [1]\nassert longest_subarray_with_sum_limit(list(range(1, 10**6 + 1)), 2) == [1], 'Failed to handle case where the subarray length is 1.'\n\n### The nums list contains 10^6 elements with increasing values from 1 to 10^6\n### The longest subarray with sum less than or equal to 5 is [1, 2]\nassert longest_subarray_with_sum_limit(list(range(1, 10**6 + 1)), 5) == [1, 2], 'Failed to handle case where the subarray length is 2.'\n\n### The nums list contains 10^6 elements, all of which are 10^6\n### The sum of all the elements in nums is 10^12, which is larger than the target\n### Therefore, there is no subarray that satisfies the condition and the function should return an empty list\nassert longest_subarray_with_sum_limit([10**8] * 10**6, 10**7) == [], 'Failed to handle case where no subarray satisfies the condition.'\n\n### The nums list contains 10^6 elements with increasing values from 1 to 10^6\n### The target is the sum of all the elements in nums, so the entire array is a valid subarray\nassert longest_subarray_with_sum_limit(list(range(1, 10**5 + 1)), 10**10) == list(range(1, 10**5 + 1)), 'Failed to handle case where the entire array is a valid subarray.'\n\n## Specific Quality Requirements\n### Robustness\n#### The sum of the elements in nums is larger than the target,\n#### so the function should return None\nassert longest_subarray_with_sum_limit([10**20, 10**20], 10**19) == None, 'Failed to handle case where the sum of the elements in nums is larger than the target.'\n\n#### The nums input is not a list of integers, so the function should return None\nassert longest_subarray_with_sum_limit('invalid', 10) == None, 'Failed to handle case where the input nums is not a list.'\n\n#### The target input is not an integer, so the function should return None\nassert longest_subarray_with_sum_limit([1, 2, 3], 'invalid') == None, 'Failed to handle case where the input target is not an integer.'\n\n#### The nums list contains elements that are not integers, so the function should return None\nassert longest_subarray_with_sum_limit([1, 2, 'invalid', 4], 5) == None, 'Failed to handle case where the input nums contains non-integer elements.'\n\n#### The target is a negative number, so the function should return None\nassert longest_subarray_with_sum_limit([1, 2, 3, 4, 5], -10) == None, 'Failed to handle case where the input target is negative.'\n\n### Maintainability\n#### Calculate Maintainability Index (MI) using Radon\n#### Check if the MI score is more than 60\nfrom radon.metrics import mi_visit\nscore = mi_visit('''${prediction}''', False)\nassert score >= 60, f'Your code has an MI score of {score}. Maintainability Index should be at least 60.'",
    "gen_tc_fr": "# Test Cases Regarding Functional Requirements\n## General Cases\n### The longest subarray with sum less than or equal to 10 is [1, 5, 2, 1]\nassert longest_subarray_with_sum_limit([3, 1, 5, 2, 1, 9, 7, 4], 10) == [1, 5, 2, 1], 'Failed to find the longest subarray.'\n\n### None of the subarrays have a sum less than or equal to 3\n### The function should return an empty list\nassert longest_subarray_with_sum_limit([2, 3, 4, 5, 6], 1) == [], 'Failed to handle case where no subarray satisfies the condition.'\n\n## Edge Cases\n### The input list is empty, so the function should return an empty list\nassert longest_subarray_with_sum_limit([], 5) == [], 'Failed to handle an empty input list.'\n\n### The longest subarray with sum less than or equal to 10 is [5, 5]\nassert longest_subarray_with_sum_limit([5, 5, 5, 5], 10) == [5, 5], 'Failed to find the longest subarray when all elements have the same value.'\n\n### The entire nums array is a valid subarray with sum less than or equal to 15\nassert longest_subarray_with_sum_limit([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5], 'Failed to handle case where the entire array is a valid subarray.'",
    "draft_plan": "- Initialize variables:\n  - `left` and `right`: Pointers to traverse through the array, initially set to 0.\n  - `max_length`: Keep track of the maximum length of the subarray found, initially set to 0.\n  - `current_sum`: Keep track of the current sum of the subarray, initially set to 0.\n  - `result`: An empty list to store the longest subarray found.\n- Find an initial valid subarray:\n  - While `right` pointer is within bounds and adding `nums[right]` to `current_sum` doesn't exceed the `target`, do the following:\n    - Add `nums[right]` to `current_sum`.\n    - Move `right` pointer one step to the right.\n- Traverse through the array:\n  - While `right` pointer is within bounds, do the following:\n    - Add `nums[right]` to `current_sum`.\n    - While `current_sum` exceeds the `target`, subtract `nums[left]` from `current_sum` and move `left` pointer one step to the right.\n    - If the length of the current subarray (`right - left + 1`) is greater than `max_length`, update `max_length` and update `result` with the current subarray.\n    - Move `right` pointer one step to the right.\n- Return the result:\n  - Return the longest subarray found, stored in `result`.",
    "final_plan": "- Input Validation\n  - Return an empty list if `nums` is not a list or contains non-integer elements.\n  - Return an empty list if `target` is not an integer.\n- Handle Special Cases\n  - If `nums` is empty, return an empty list since there's no subarray to find.\n- Initialize variables:\n  - `left` and `right`: Pointers to traverse through the array, initially set to 0.\n  - `max_length`: Keep track of the maximum length of the subarray found, initially set to 0.\n  - `current_sum`: Keep track of the current sum of the subarray, initially set to 0.\n  - `result`: An empty list to store the longest subarray found.\n- Find an initial valid subarray:\n  - While `right` pointer is within bounds and adding `nums[right]` to `current_sum` doesn't exceed the `target`, do the following:\n    - Add `nums[right]` to `current_sum`.\n    - Move `right` pointer one step to the right.\n  - If the window size is greater than 0 (valid subarray found), update `result` with the current subarray and `max_length` accordingly.\n- Find Longest Subarray\n  - Continue while `right` pointer is within the array bounds:\n    - Add `nums[right]` to `current_sum`.\n    - While `current_sum` exceeds the `target`, subtract `nums[left]` from `current_sum` and increment `left`.\n    - If the current window size (`right - left + 1`) is greater than `max_length`, update `max_length` and `result` with the current subarray.\n    - Increment `right`.\n- Return Result\n  - Return `result` as the output, which holds the longest subarray with sum <= target.",
    "draft_code": "n = len(nums)\nleft, right = 0, 0\nmax_length = 0\ncurrent_sum = 0\nresult = []\n\nwhile right < n and current_sum + nums[right] <= target:\n    current_sum += nums[right]\n    right += 1\n\nif right > 0:\n    result = nums[left:right]\n    max_length = right\n\nwhile right < n:\n    current_sum += nums[right]\n    \n    while current_sum > target:\n        current_sum -= nums[left]\n        left += 1\n    \n    if right - left + 1 > max_length:\n        max_length = right - left + 1\n        result = nums[left:right+1]\n    \n    right += 1\n\nreturn result",
    "code": "# Validate inputs\nif not isinstance(nums, list) or not all(isinstance(num, int) for num in nums):\n    sys.stderr.write('Invalid input: nums must be a list of integers.')\n    return\nif not isinstance(target, int):\n    sys.stderr.write('Invalid input: target must be an integer.')\n    return\n\nn = len(nums)\nleft, right = 0, 0\nmax_length = 0\ncurrent_sum = 0\nresult = []\n\n# Handle empty list\nif n == 0:\n    return []\n\n# Initial window expansion\nwhile right < n and current_sum + nums[right] <= target:\n    current_sum += nums[right]\n    right += 1\n\n# Update result if a valid window was found during initial expansion\nif right > 0:\n    result = nums[left:right]\n    max_length = right\n\n# Main loop: Slide the window through the array\nwhile right < n:\n    current_sum += nums[right]\n    \n    # Shrink window from the left if current_sum exceeds target\n    while current_sum > target:\n        current_sum -= nums[left]\n        left += 1\n    \n    # Update result if a longer valid window is found\n    if right - left + 1 > max_length:\n        max_length = right - left + 1\n        result = nums[left:right+1]\n    \n    right += 1\n\nreturn result",
    "gen_tc_def": "def check(candidate):\n    # Test Cases Regarding Functional Requirements\n    ## General Cases\n    ### The longest subarray with sum less than or equal to 10 is [1, 5, 2, 1]\n    assert candidate([3, 1, 5, 2, 1, 9, 7, 4], 10) == [1, 5, 2, 1], 'Failed to find the longest subarray.'\n\n    ### None of the subarrays have a sum less than or equal to 3\n    ### The function should return an empty list\n    assert candidate([2, 3, 4, 5, 6], 1) == [], 'Failed to handle case where no subarray satisfies the condition.'\n\n    ## Edge Cases\n    ### The input list is empty, so the function should return an empty list\n    assert candidate([], 5) == [], 'Failed to handle an empty input list.'\n\n    ### The longest subarray with sum less than or equal to 10 is [5, 5]\n    assert candidate([5, 5, 5, 5], 10) == [5, 5], 'Failed to find the longest subarray when all elements have the same value.'\n\n    ### The entire nums array is a valid subarray with sum less than or equal to 15\n    assert candidate([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5], 'Failed to handle case where the entire array is a valid subarray.'\n\ncheck(longest_subarray_with_sum_limit)"
  }
]
